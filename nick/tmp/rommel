function init() {
	var data = {
		"nodes" : [{
			"x" : 469,
			"y" : 410
		}, {
			"x" : 493,
			"y" : 364
		}, {
			"x" : 442,
			"y" : 365
		}, {
			"x" : 467,
			"y" : 314
		}, {
			"x" : 477,
			"y" : 248
		}, {
			"x" : 425,
			"y" : 207
		}, {
			"x" : 402,
			"y" : 155
		}, {
			"x" : 369,
			"y" : 196
		}, {
			"x" : 350,
			"y" : 148
		}, {
			"x" : 539,
			"y" : 222
		}, {
			"x" : 594,
			"y" : 235
		}, {
			"x" : 582,
			"y" : 185
		}, {
			"x" : 633,
			"y" : 200
		}],
		"links" : [{
			"source" : 0,
			"target" : 1
		}, {
			"source" : 1,
			"target" : 2
		}, {
			"source" : 2,
			"target" : 0
		}, {
			"source" : 1,
			"target" : 3
		}, {
			"source" : 3,
			"target" : 2
		}, {
			"source" : 3,
			"target" : 4
		}, {
			"source" : 4,
			"target" : 5
		}, {
			"source" : 5,
			"target" : 6
		}, {
			"source" : 5,
			"target" : 7
		}, {
			"source" : 6,
			"target" : 7
		}, {
			"source" : 6,
			"target" : 8
		}, {
			"source" : 7,
			"target" : 8
		}, {
			"source" : 9,
			"target" : 4
		}, {
			"source" : 9,
			"target" : 11
		}, {
			"source" : 9,
			"target" : 10
		}, {
			"source" : 10,
			"target" : 11
		}, {
			"source" : 11,
			"target" : 12
		}, {
			"source" : 12,
			"target" : 10
		}]
	};
	//Set visualisation variables
	var WIDTH = 1000,
	    HEIGHT = 600;
	COLOR = "steelblue";
	LINK_COLOR = "#cccccc";

	var scene = new THREE.Scene();


	// set some camera attributes
	var VIEW_ANGLE = 45,
	    ASPECT = WIDTH / HEIGHT,
	    NEAR = 0.1,
	    FAR = 10000;

	var $container = $('#canvas-svg');

	var renderer = new THREE.WebGLRenderer({
		alpha : true,
		antialiasing : true
	});
	renderer.setClearColor(0x000000, 0);

	var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

	var scene = new THREE.Scene();
	var controls = new THREE.TrackballControls(camera);

	// add the camera to the scene
	scene.add(camera);
	camera.position.z = 300;

	// start the renderer
	renderer.setSize(WIDTH, HEIGHT);

	// attach the render-supplied DOM element
	$container.append(renderer.domElement);

	var spheres = [],
	    three_links = [];

	// Define the 3d force
	var force = d3.layout.force3d().nodes( sort_data = []).links( links = []).size([50, 50]).gravity(0.3).charge(-400);
	var DISTANCE = 1;

//This function adds interactivity to the visualization by allowing it to be moved and zoomed in upon
function initControls() {

    controls.rotateSpeed = 0.5;
    controls.minDistance = 500;
    controls.maxDistance = 6000;
    controls.addEventListener('change', render);
}

	function createNodes() {
		for (var i = 0; i < data.nodes.length; i++) {
			sort_data.push({
				x : data.nodes.x + DISTANCE,
				y : data.nodes.y + DISTANCE,
				z : 0
			});

			// set up the sphere vars
			var radius = 5,
			    segments = 16,
			    rings = 16;

			// create the sphere's material
			var sphereMaterial = new THREE.MeshLambertMaterial({
				color : COLOR
			});

			var sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, segments, rings), sphereMaterial);

			spheres.push(sphere);

			// add the sphere to the scene
			scene.add(sphere);
		}

		for (var i = 0; i < data.links.length; i++) {
			links.push({
				target : sort_data[data.links[i].target],
				source : sort_data[data.links[i].source]
			});

			var material = new THREE.LineBasicMaterial({
				color : LINK_COLOR,
				linewidth : 2
			});
			var geometry = new THREE.Geometry();

			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			var line = new THREE.Line(geometry, material);
			line.userData = {
				source : data.links[i].source,
				target : data.links[i].target
			};
			three_links.push(line);
			scene.add(line);

			force.start();
		}
	}

	createNodes();

	function initForce3D() {
		// set up the axes
		var x = d3.scale.linear().domain([0, 350]).range([0, 10]),
		    y = d3.scale.linear().domain([0, 350]).range([0, 10]),
		    z = d3.scale.linear().domain([0, 350]).range([0, 10]);

		force.on("tick", function(e) {
			for (var i = 0; i < sort_data.length; i++) {
				spheres[i].position.set(x(sort_data[i].x) * 40 - 40, y(sort_data[i].y) * 40 - 40, 0);

				for (var j = 0; j < three_links.length; j++) {
					var line = three_links[j];
					var vi = -1;
					if (line.userData.source === i) {
						vi = 0;
					}
					if (line.userData.target === i) {
						vi = 1;
					}

					if (vi >= 0) {
						line.geometry.vertices[vi].x = x(sort_data[i].x) * 40 - 40;
						line.geometry.vertices[vi].y = y(sort_data[i].y) * 40 - 40;
						line.geometry.verticesNeedUpdate = true;
					}
				}
			}

			renderer.render(scene, camera);
		});
	}

	initForce3D();

	function initPointLight() {
		// create a point light
		var pointLight = new THREE.PointLight(0xFFFFFF);

		// set its position
		pointLight.position.x = 10;
		pointLight.position.y = 50;
		pointLight.position.z = 130;

		// add to the scene
		scene.add(pointLight);
	};
	initPointLight();

	function animate() {
		requestAnimationFrame(animate);
		renderer.render(scene, camera);
		controls.update();
	}

	function render() {
		renderer.render(scene, camera);
		animate();
	}
	
	animate();

}